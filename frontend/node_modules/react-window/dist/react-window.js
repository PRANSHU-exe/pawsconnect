import { jsx as _ } from "react/jsx-runtime";
import { useState as j, useLayoutEffect as ee, useEffect as te, useMemo as H, useRef as K, useCallback as N, memo as ie, useImperativeHandle as le, createElement as P } from "react";
function pe(e) {
  let t = e;
  for (; t; ) {
    if (t.dir)
      return t.dir === "rtl";
    t = t.parentElement;
  }
  return !1;
}
function xe(e, t) {
  const [s, r] = j(t === "rtl");
  return ee(() => {
    e && (t || r(pe(e)));
  }, [t, e]), s;
}
const J = typeof window < "u" ? ee : te;
function ne(e) {
  if (e !== void 0)
    switch (typeof e) {
      case "number":
        return e;
      case "string": {
        if (e.endsWith("px"))
          return parseFloat(e);
        break;
      }
    }
}
function ge({
  box: e,
  defaultHeight: t,
  defaultWidth: s,
  disabled: r,
  element: o,
  mode: n,
  style: l
}) {
  const { styleHeight: c, styleWidth: i } = H(
    () => ({
      styleHeight: ne(l?.height),
      styleWidth: ne(l?.width)
    }),
    [l?.height, l?.width]
  ), [f, d] = j({
    height: t,
    width: s
  }), p = r || n === "only-height" && c !== void 0 || n === "only-width" && i !== void 0 || c !== void 0 && i !== void 0;
  return J(() => {
    if (o === null || p)
      return;
    const y = new ResizeObserver((S) => {
      for (const V of S) {
        const { contentRect: b, target: g } = V;
        o === g && d((m) => m.height === b.height && m.width === b.width ? m : {
          height: b.height,
          width: b.width
        });
      }
    });
    return y.observe(o, { box: e }), () => {
      y?.unobserve(o);
    };
  }, [e, p, o, c, i]), H(
    () => ({
      height: c ?? f.height,
      width: i ?? f.width
    }),
    [f, c, i]
  );
}
function Ie(e) {
  const t = K(() => {
    throw new Error("Cannot call an event handler while rendering.");
  });
  return J(() => {
    t.current = e;
  }, [e]), N((s) => t.current?.(s), [t]);
}
let G = null;
function ve(e = !1) {
  if (G === null || e) {
    const t = document.createElement("div"), s = t.style;
    s.width = "50px", s.height = "50px", s.overflow = "scroll", s.direction = "rtl";
    const r = document.createElement("div"), o = r.style;
    return o.width = "100px", o.height = "100px", t.appendChild(r), document.body.appendChild(t), t.scrollLeft > 0 ? G = "positive-descending" : (t.scrollLeft = 1, t.scrollLeft === 0 ? G = "negative" : G = "positive-ascending"), document.body.removeChild(t), G;
  }
  return G;
}
function X({
  containerElement: e,
  direction: t,
  isRtl: s,
  scrollOffset: r
}) {
  if (t === "horizontal" && s)
    switch (ve()) {
      case "negative":
        return -r;
      case "positive-descending": {
        if (e) {
          const { clientWidth: o, scrollLeft: n, scrollWidth: l } = e;
          return l - o - n;
        }
        break;
      }
    }
  return r;
}
function B(e, t = "Assertion error") {
  if (!e)
    throw console.error(t), Error(t);
}
function Y(e, t) {
  if (e === t)
    return !0;
  if (!!e != !!t || (B(e !== void 0), B(t !== void 0), Object.keys(e).length !== Object.keys(t).length))
    return !1;
  for (const s in e)
    if (!Object.is(t[s], e[s]))
      return !1;
  return !0;
}
function ce({
  cachedBounds: e,
  itemCount: t,
  itemSize: s
}) {
  if (t === 0)
    return 0;
  if (typeof s == "number")
    return t * s;
  {
    const r = e.get(
      e.size === 0 ? 0 : e.size - 1
    );
    B(r !== void 0, "Unexpected bounds cache miss");
    const o = (r.scrollOffset + r.size) / e.size;
    return t * o;
  }
}
function be({
  align: e,
  cachedBounds: t,
  index: s,
  itemCount: r,
  itemSize: o,
  containerScrollOffset: n,
  containerSize: l
}) {
  const c = ce({
    cachedBounds: t,
    itemCount: r,
    itemSize: o
  }), i = t.get(s), f = Math.max(
    0,
    Math.min(c - l, i.scrollOffset)
  ), d = Math.max(
    0,
    i.scrollOffset - l + i.size
  );
  switch (e === "smart" && (n >= d && n <= f ? e = "auto" : e = "center"), e) {
    case "start":
      return f;
    case "end":
      return d;
    case "center":
      return i.scrollOffset <= l / 2 ? 0 : i.scrollOffset + i.size / 2 >= c - l / 2 ? c - l : i.scrollOffset + i.size / 2 - l / 2;
    case "auto":
    default:
      return n >= d && n <= f ? n : n < d ? d : f;
  }
}
function oe({
  cachedBounds: e,
  containerScrollOffset: t,
  containerSize: s,
  itemCount: r,
  overscanCount: o
}) {
  const n = r - 1;
  let l = 0, c = -1, i = 0, f = -1, d = 0;
  for (; d < n; ) {
    const p = e.get(d);
    if (p.scrollOffset + p.size > t)
      break;
    d++;
  }
  for (l = d, i = Math.max(0, l - o); d < n; ) {
    const p = e.get(d);
    if (p.scrollOffset + p.size >= t + s)
      break;
    d++;
  }
  return c = Math.min(n, d), f = Math.min(r - 1, c + o), l < 0 && (l = 0, c = -1, i = 0, f = -1), {
    startIndexVisible: l,
    stopIndexVisible: c,
    startIndexOverscan: i,
    stopIndexOverscan: f
  };
}
function me({
  itemCount: e,
  itemProps: t,
  itemSize: s
}) {
  const r = /* @__PURE__ */ new Map();
  return {
    get(o) {
      for (B(o < e, `Invalid index ${o}`); r.size - 1 < o; ) {
        const l = r.size;
        let c;
        switch (typeof s) {
          case "function": {
            c = s(l, t);
            break;
          }
          case "number": {
            c = s;
            break;
          }
        }
        if (l === 0)
          r.set(l, {
            size: c,
            scrollOffset: 0
          });
        else {
          const i = r.get(l - 1);
          B(
            i !== void 0,
            `Unexpected bounds cache miss for index ${o}`
          ), r.set(l, {
            scrollOffset: i.scrollOffset + i.size,
            size: c
          });
        }
      }
      const n = r.get(o);
      return B(
        n !== void 0,
        `Unexpected bounds cache miss for index ${o}`
      ), n;
    },
    set(o, n) {
      r.set(o, n);
    },
    get size() {
      return r.size;
    }
  };
}
function we({
  itemCount: e,
  itemProps: t,
  itemSize: s
}) {
  return H(
    () => me({
      itemCount: e,
      itemProps: t,
      itemSize: s
    }),
    [e, t, s]
  );
}
function Oe({
  containerSize: e,
  itemSize: t
}) {
  let s;
  switch (typeof t) {
    case "string": {
      B(
        t.endsWith("%"),
        `Invalid item size: "${t}"; string values must be percentages (e.g. "100%")`
      ), B(
        e !== void 0,
        "Container size must be defined if a percentage item size is specified"
      ), s = e * parseInt(t) / 100;
      break;
    }
    default: {
      s = t;
      break;
    }
  }
  return s;
}
function C({
  containerElement: e,
  containerStyle: t,
  defaultContainerSize: s = 0,
  direction: r,
  isRtl: o = !1,
  itemCount: n,
  itemProps: l,
  itemSize: c,
  onResize: i,
  overscanCount: f
}) {
  const [d, p] = j({
    startIndexVisible: 0,
    startIndexOverscan: 0,
    stopIndexVisible: -1,
    stopIndexOverscan: -1
  }), {
    startIndexVisible: y,
    startIndexOverscan: S,
    stopIndexVisible: V,
    stopIndexOverscan: b
  } = {
    startIndexVisible: Math.min(n - 1, d.startIndexVisible),
    startIndexOverscan: Math.min(n - 1, d.startIndexOverscan),
    stopIndexVisible: Math.min(n - 1, d.stopIndexVisible),
    stopIndexOverscan: Math.min(n - 1, d.stopIndexOverscan)
  }, { height: g = s, width: m = s } = ge({
    defaultHeight: r === "vertical" ? s : void 0,
    defaultWidth: r === "horizontal" ? s : void 0,
    element: e,
    mode: r === "vertical" ? "only-height" : "only-width",
    style: t
  }), k = K({
    height: 0,
    width: 0
  }), O = r === "vertical" ? g : m, a = Oe({ containerSize: O, itemSize: c });
  ee(() => {
    if (typeof i == "function") {
      const u = k.current;
      (u.height !== g || u.width !== m) && (i({ height: g, width: m }, { ...u }), u.height = g, u.width = m);
    }
  }, [g, i, m]);
  const x = we({
    itemCount: n,
    itemProps: l,
    itemSize: a
  }), z = N(
    (u) => x.get(u),
    [x]
  ), T = N(
    () => ce({
      cachedBounds: x,
      itemCount: n,
      itemSize: a
    }),
    [x, n, a]
  ), M = N(
    (u) => {
      const I = X({
        containerElement: e,
        direction: r,
        isRtl: o,
        scrollOffset: u
      });
      return oe({
        cachedBounds: x,
        containerScrollOffset: I,
        containerSize: O,
        itemCount: n,
        overscanCount: f
      });
    },
    [
      x,
      e,
      O,
      r,
      o,
      n,
      f
    ]
  );
  J(() => {
    const u = (r === "vertical" ? e?.scrollTop : e?.scrollLeft) ?? 0;
    p(M(u));
  }, [e, r, M]), J(() => {
    if (!e)
      return;
    const u = () => {
      p((I) => {
        const { scrollLeft: h, scrollTop: v } = e, E = X({
          containerElement: e,
          direction: r,
          isRtl: o,
          scrollOffset: r === "vertical" ? v : h
        }), q = oe({
          cachedBounds: x,
          containerScrollOffset: E,
          containerSize: O,
          itemCount: n,
          overscanCount: f
        });
        return Y(q, I) ? I : q;
      });
    };
    return e.addEventListener("scroll", u), () => {
      e.removeEventListener("scroll", u);
    };
  }, [
    x,
    e,
    O,
    r,
    n,
    f
  ]);
  const L = Ie(
    ({
      align: u = "auto",
      containerScrollOffset: I,
      index: h
    }) => {
      let v = be({
        align: u,
        cachedBounds: x,
        containerScrollOffset: I,
        containerSize: O,
        index: h,
        itemCount: n,
        itemSize: a
      });
      if (e) {
        if (v = X({
          containerElement: e,
          direction: r,
          isRtl: o,
          scrollOffset: v
        }), typeof e.scrollTo != "function") {
          const E = M(v);
          Y(d, E) || p(E);
        }
        return v;
      }
    }
  );
  return {
    getCellBounds: z,
    getEstimatedSize: T,
    scrollToIndex: L,
    startIndexOverscan: S,
    startIndexVisible: y,
    stopIndexOverscan: b,
    stopIndexVisible: V
  };
}
function de(e) {
  return H(() => e, Object.values(e));
}
function ae(e, t) {
  const {
    ariaAttributes: s,
    style: r,
    ...o
  } = e, {
    ariaAttributes: n,
    style: l,
    ...c
  } = t;
  return Y(s, n) && Y(r, l) && Y(o, c);
}
function ze({
  cellComponent: e,
  cellProps: t,
  children: s,
  className: r,
  columnCount: o,
  columnWidth: n,
  defaultHeight: l = 0,
  defaultWidth: c = 0,
  dir: i,
  gridRef: f,
  onCellsRendered: d,
  onResize: p,
  overscanCount: y = 3,
  rowCount: S,
  rowHeight: V,
  style: b,
  tagName: g = "div",
  ...m
}) {
  const k = de(t), O = H(
    () => ie(e, ae),
    [e]
  ), [a, x] = j(null), z = xe(a, i), {
    getCellBounds: T,
    getEstimatedSize: M,
    startIndexOverscan: L,
    startIndexVisible: u,
    scrollToIndex: I,
    stopIndexOverscan: h,
    stopIndexVisible: v
  } = C({
    containerElement: a,
    containerStyle: b,
    defaultContainerSize: c,
    direction: "horizontal",
    isRtl: z,
    itemCount: o,
    itemProps: k,
    itemSize: n,
    onResize: p,
    overscanCount: y
  }), {
    getCellBounds: E,
    getEstimatedSize: q,
    startIndexOverscan: F,
    startIndexVisible: se,
    scrollToIndex: Q,
    stopIndexOverscan: U,
    stopIndexVisible: re
  } = C({
    containerElement: a,
    containerStyle: b,
    defaultContainerSize: l,
    direction: "vertical",
    itemCount: S,
    itemProps: k,
    itemSize: V,
    onResize: p,
    overscanCount: y
  });
  le(
    f,
    () => ({
      get element() {
        return a;
      },
      scrollToCell({
        behavior: R = "auto",
        columnAlign: w = "auto",
        columnIndex: W,
        rowAlign: A = "auto",
        rowIndex: $
      }) {
        const D = I({
          align: w,
          containerScrollOffset: a?.scrollLeft ?? 0,
          index: W
        }), he = Q({
          align: A,
          containerScrollOffset: a?.scrollTop ?? 0,
          index: $
        });
        typeof a?.scrollTo == "function" && a.scrollTo({
          behavior: R,
          left: D,
          top: he
        });
      },
      scrollToColumn({
        align: R = "auto",
        behavior: w = "auto",
        index: W
      }) {
        const A = I({
          align: R,
          containerScrollOffset: a?.scrollLeft ?? 0,
          index: W
        });
        typeof a?.scrollTo == "function" && a.scrollTo({
          behavior: w,
          left: A
        });
      },
      scrollToRow({
        align: R = "auto",
        behavior: w = "auto",
        index: W
      }) {
        const A = Q({
          align: R,
          containerScrollOffset: a?.scrollTop ?? 0,
          index: W
        });
        typeof a?.scrollTo == "function" && a.scrollTo({
          behavior: w,
          top: A
        });
      }
    }),
    [a, I, Q]
  ), te(() => {
    L >= 0 && h >= 0 && F >= 0 && U >= 0 && d && d(
      {
        columnStartIndex: u,
        columnStopIndex: v,
        rowStartIndex: se,
        rowStopIndex: re
      },
      {
        columnStartIndex: L,
        columnStopIndex: h,
        rowStartIndex: F,
        rowStopIndex: U
      }
    );
  }, [
    d,
    L,
    u,
    h,
    v,
    F,
    se,
    U,
    re
  ]);
  const fe = H(() => {
    const R = [];
    if (o > 0 && S > 0)
      for (let w = F; w <= U; w++) {
        const W = E(w), A = [];
        for (let $ = L; $ <= h; $++) {
          const D = T($);
          A.push(
            /* @__PURE__ */ P(
              O,
              {
                ...k,
                ariaAttributes: {
                  "aria-colindex": $ + 1,
                  role: "gridcell"
                },
                columnIndex: $,
                key: $,
                rowIndex: w,
                style: {
                  position: "absolute",
                  left: z ? void 0 : 0,
                  right: z ? 0 : void 0,
                  transform: `translate(${z ? -D.scrollOffset : D.scrollOffset}px, ${W.scrollOffset}px)`,
                  height: W.size,
                  width: D.size
                }
              }
            )
          );
        }
        R.push(
          /* @__PURE__ */ _("div", { role: "row", "aria-rowindex": w + 1, children: A }, w)
        );
      }
    return R;
  }, [
    O,
    k,
    o,
    L,
    h,
    T,
    E,
    z,
    S,
    F,
    U
  ]), ue = /* @__PURE__ */ _(
    "div",
    {
      "aria-hidden": !0,
      style: {
        height: q(),
        width: M(),
        zIndex: -1
      }
    }
  );
  return P(
    g,
    {
      "aria-colcount": o,
      "aria-rowcount": S,
      role: "grid",
      ...m,
      className: r,
      dir: i,
      ref: x,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        maxHeight: "100%",
        maxWidth: "100%",
        flexGrow: 1,
        overflow: "auto",
        ...b
      }
    },
    fe,
    s,
    ue
  );
}
const Te = j, Ve = K;
function ke({
  children: e,
  className: t,
  defaultHeight: s = 0,
  listRef: r,
  onResize: o,
  onRowsRendered: n,
  overscanCount: l = 3,
  rowComponent: c,
  rowCount: i,
  rowHeight: f,
  rowProps: d,
  tagName: p = "div",
  style: y,
  ...S
}) {
  const V = de(d), b = H(
    () => ie(c, ae),
    [c]
  ), [g, m] = j(null), {
    getCellBounds: k,
    getEstimatedSize: O,
    scrollToIndex: a,
    startIndexOverscan: x,
    startIndexVisible: z,
    stopIndexOverscan: T,
    stopIndexVisible: M
  } = C({
    containerElement: g,
    containerStyle: y,
    defaultContainerSize: s,
    direction: "vertical",
    itemCount: i,
    itemProps: V,
    itemSize: f,
    onResize: o,
    overscanCount: l
  });
  le(
    r,
    () => ({
      get element() {
        return g;
      },
      scrollToRow({
        align: I = "auto",
        behavior: h = "auto",
        index: v
      }) {
        const E = a({
          align: I,
          containerScrollOffset: g?.scrollTop ?? 0,
          index: v
        });
        typeof g?.scrollTo == "function" && g.scrollTo({
          behavior: h,
          top: E
        });
      }
    }),
    [g, a]
  ), te(() => {
    x >= 0 && T >= 0 && n && n(
      {
        startIndex: z,
        stopIndex: M
      },
      {
        startIndex: x,
        stopIndex: T
      }
    );
  }, [
    n,
    x,
    z,
    T,
    M
  ]);
  const L = H(() => {
    const I = [];
    if (i > 0)
      for (let h = x; h <= T; h++) {
        const v = k(h);
        I.push(
          /* @__PURE__ */ P(
            b,
            {
              ...V,
              ariaAttributes: {
                "aria-posinset": h + 1,
                "aria-setsize": i,
                role: "listitem"
              },
              key: h,
              index: h,
              style: {
                position: "absolute",
                left: 0,
                transform: `translateY(${v.scrollOffset}px)`,
                height: v.size,
                width: "100%"
              }
            }
          )
        );
      }
    return I;
  }, [
    b,
    k,
    i,
    V,
    x,
    T
  ]), u = /* @__PURE__ */ _(
    "div",
    {
      "aria-hidden": !0,
      style: {
        height: O(),
        width: "100%",
        zIndex: -1
      }
    }
  );
  return P(
    p,
    {
      role: "list",
      ...S,
      className: t,
      ref: m,
      style: {
        position: "relative",
        maxHeight: "100%",
        flexGrow: 1,
        overflowY: "auto",
        ...y
      }
    },
    L,
    e,
    u
  );
}
const Le = j, Ee = K;
let Z = -1;
function Me(e = !1) {
  if (Z === -1 || e) {
    const t = document.createElement("div"), s = t.style;
    s.width = "50px", s.height = "50px", s.overflow = "scroll", document.body.appendChild(t), Z = t.offsetWidth - t.clientWidth, document.body.removeChild(t);
  }
  return Z;
}
export {
  ze as Grid,
  ke as List,
  Me as getScrollbarSize,
  Te as useGridCallbackRef,
  Ve as useGridRef,
  Le as useListCallbackRef,
  Ee as useListRef
};
//# sourceMappingURL=react-window.js.map
